From 2da93e149a80798cd7a152f590b47c0fdaff62d3 Mon Sep 17 00:00:00 2001
From: Pontus Fuchs <pontus.fuchs@gmail.com>
Date: Sun, 2 Sep 2012 19:18:21 +0200
Subject: [PATCH 15/82] Improve TX handling

---
 ar5523.c |   63 +++++++++++++++++++++----------
 ar5523.h |  126 +++++++++-----------------------------------------------------
 2 files changed, 60 insertions(+), 129 deletions(-)

--- a/drivers/net/wireless/ath/ar5523/ar5523.c
+++ b/drivers/net/wireless/ath/ar5523/ar5523.c
@@ -78,9 +78,14 @@ enum {
 	AR5523_TX_CMD_COUNT	= 2,
 
 	AR5523_TX_DATA_COUNT	= 16,
+	AR5523_TX_DATA_RESTART_COUNT = 8,
 	AR5523_RX_DATA_COUNT	= 16,
 };
 
+enum AR5523_flags {
+	AR5523_TX_QUEUE_STOPPED
+};
+
 struct ar5523_tx_cmd {
 	struct	list_head	list;
 	int			id;
@@ -116,6 +121,7 @@ struct ar5523 {
 	struct usb_device	*dev;
 	struct ieee80211_hw	*hw;
 
+	unsigned long		flags;
 	struct mutex		mutex;
 	struct ar5523_tx_cmd	tx_cmd[AR5523_TX_CMD_COUNT];
 	wait_queue_head_t	tx_cmd_wait;
@@ -963,17 +969,13 @@ static int ar5523_set_rts_threshold(stru
 	return ret;
 }
 
-static inline struct ar5523_tx_data *ar5523_get_tx_priv(struct sk_buff *skb)
-{
-	return (struct ar5523_tx_data*) &IEEE80211_SKB_CB(skb)->driver_data;
-}
-
 static void ar5523_data_tx_cb(struct urb *urb)
 {
 	struct sk_buff *skb = urb->context;
-	struct ar5523_tx_data *data = ar5523_get_tx_priv(skb);
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct ar5523_tx_data *data = (struct ar5523_tx_data *)
+				       txi->driver_data;
 	struct ar5523 *ar = data->ar;
-	struct ieee80211_tx_info *txi;
 
 	ar5523_dbg(ar, "data tx urb completed\n");
 
@@ -985,32 +987,49 @@ static void ar5523_data_tx_cb(struct urb
 		goto out;
 	}
 
-	txi = IEEE80211_SKB_CB(skb);
 	skb_pull(skb, sizeof(struct ar5523_tx_desc) + sizeof(__be32));
 
 	txi->flags |= IEEE80211_TX_STAT_ACK;
 	ieee80211_tx_status_irqsafe(ar->hw, skb);
 out:
 	atomic_dec(&ar->tx_data_queued);
+
+	if (atomic_read(&ar->tx_data_queued) < AR5523_TX_DATA_RESTART_COUNT) {
+		if (test_and_clear_bit(AR5523_TX_QUEUE_STOPPED, &ar->flags)) {
+			ar5523_dbg(ar, "restart tx queue\n");
+			ieee80211_wake_queues(ar->hw);
+		}
+	}
+
 	usb_free_urb(urb);
 }
 
 static void ar5523_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 	struct ieee80211_hdr *wh = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
 	struct ar5523 *ar = hw->priv;
-	struct ar5523_tx_data *data;
+	struct ar5523_tx_data *data = (struct ar5523_tx_data *)
+				       txi->driver_data;
 	struct ar5523_tx_desc *desc;
 	struct urb *urb;
 	int paylen = skb->len;
 	int error = 0;
 	__be32 *hdr;
+	u32 txqid;
 
 	ar5523_dbg(ar, "tx called\n");
 
-	if (atomic_read(&ar->tx_data_queued) >= AR5523_TX_DATA_COUNT) {
+	if (atomic_read(&ar->tx_data_queued) >= (AR5523_TX_DATA_COUNT-1)) {
 		ar5523_dbg(ar, "tx queue full\n");
-		printk("tx queue full\n");
+		if (!test_and_set_bit(AR5523_TX_QUEUE_STOPPED, &ar->flags)) {
+			ar5523_dbg(ar, "stop queues\n");
+			ieee80211_stop_queues(hw);
+		}
+	}
+
+	if (atomic_read(&ar->tx_data_queued) >= AR5523_TX_DATA_COUNT) {
+		WARN_ON(1);
 		return;
 	}
 
@@ -1018,7 +1037,6 @@ static void ar5523_tx(struct ieee80211_h
 	if (!urb)
 		goto out_free_skb;
 	
-	data = ar5523_get_tx_priv(skb);
 	data->ar = ar;
 
 	desc = (struct ar5523_tx_desc *)skb_push(skb, sizeof(*desc));
@@ -1027,10 +1045,10 @@ static void ar5523_tx(struct ieee80211_h
 	/* fill Tx descriptor */
 	*hdr = AR5523_MAKECTL(1, skb->len - sizeof(__be32));
 
-	desc->len    = cpu_to_be32(skb->len);
-	desc->priv   = 0;
-	desc->paylen = cpu_to_be32(paylen);
-	desc->type   = cpu_to_be32(AR5523_TX_DATA);
+	desc->msglen  = cpu_to_be32(skb->len);
+	desc->msgid   = 0;
+	desc->buflen = cpu_to_be32(paylen);
+	desc->type   = cpu_to_be32(WDCMSG_SEND);
 	desc->flags  = 0;
 
 	/*
@@ -1038,13 +1056,18 @@ static void ar5523_tx(struct ieee80211_h
 	 *	     the frame?
 	 */
 	if (is_multicast_ether_addr(wh->addr1)) {
-		desc->dest  = cpu_to_be32(AR5523_ID_BROADCAST);
-		desc->magic = cpu_to_be32(3);
+		desc->connid  = cpu_to_be32(AR5523_ID_BROADCAST);
+		txqid = 3;
 	} else {
-		desc->dest  = cpu_to_be32(AR5523_ID_BSS);
-		desc->magic = cpu_to_be32(1);
+		desc->connid  = cpu_to_be32(AR5523_ID_BSS);
+		txqid = 1;
 	}
 
+	if (txi->flags & IEEE80211_TX_CTL_USE_MINRATE)
+		txqid |= UATH_TXQID_MINRATE;
+
+	desc->txqid = cpu_to_be32(txqid);
+
 	usb_fill_bulk_urb(urb, ar->dev, ar5523_data_tx_pipe(ar->dev),
 			  skb->data, skb->len, ar5523_data_tx_cb, skb);
 
--- a/drivers/net/wireless/ath/ar5523/ar5523.h
+++ b/drivers/net/wireless/ath/ar5523/ar5523.h
@@ -103,39 +103,9 @@ struct ar5523_cmd_hdr {
 #define	WDCMSG_SET_DEFAULT_KEY		0x43
 
 
-
-
-#define AR5523_CMD_SETUP		0x01
-#define AR5523_CMD_02		0x02
-#define AR5523_CMD_READ_MAC	0x03
-#define AR5523_CMD_WRITE_MAC	0x04
-#define AR5523_CMD_READ_EEPROM	0x05
-#define AR5523_CMD_STATS		0x06
-#define AR5523_CMD_07		0x07
-#define AR5523_CMD_SHUTDOWN	0x08
-#define AR5523_CMD_0B		0x0b
-#define AR5523_CREATE_CONNECTION 0x0c
-#define AR5523_CMD_0F		0x0f
-#define AR5523_NOTIF_STATS	0x10
-#define AR5523_NOTIF_READY	0x12
-#define AR5523_NOTIF_TX		0x13
-#define AR5523_CMD_15		0x15
+/* OLD commands: REMOVE! */
 #define AR5523_CMD_SET_LED	0x17
 #define AR5523_CMD_SET_XLED	0x18
-#define AR5523_CMD_1B		0x1b
-#define AR5523_CMD_1E		0x1e
-#define AR5523_CMD_CRYPTO		0x1d
-#define AR5523_CMD_SET_STATE	0x20
-#define AR5523_CMD_SET_BSSID	0x21
-#define	AR5523_WRITE_ASSOCID	0x22
-#define AR5523_CMD_24		0x24
-#define AR5523_CMD_SET_ADHOC_MODE	0x26
-#define AR5523_CMD_SET_BASIC_RATES	0x27
-#define AR5523_CMD_2E		0x2e
-#define AR5523_CMD_31		0x31
-#define AR5523_CMD_SET_FILTER	0x32
-#define AR5523_CMD_SET_CHAN	0x34
-#define AR5523_CMD_RESET		0x35
 #define AR5523_CMD_SET_QUEUE	0x3a
 #define AR5523_CMD_RESET_QUEUE	0x3b
 
@@ -202,38 +172,26 @@ struct ar5523_rx_desc {
 
 #define AR5523_MAKECTL(qid, len)	cpu_to_be32((qid) << 16 | (len))
 
-struct ar5523_tx_desc {
-	__be32		len;
-	__u32		priv;	/* driver private data
-				   don't care about endianess */
-	__be32		type;
-#define AR5523_TX_DATA	0xe
-#define AR5523_TX_NULL	0xf
-
-	__be32		magic;
-	__be32		dest;
-#define AR5523_ID_BSS		2
-#define AR5523_ID_BROADCAST	0xffffffff
 
-	__be32		flags;
-#define AR5523_TX_NOTIFY	(1 << 24)	/* f/w will send a AR5523_NOTIF_TX */
 
-	__be32		paylen;
-};
+struct ar5523_tx_desc {
+	__be32	msglen;
+	__be32	msgid;		/* msg id (supplied by host) */
+	__be32	type;		/* opcode: WDMSG_SEND or WDCMSG_FLUSH */
+	__be32	txqid;		/* tx queue id and flags */
+#define	UATH_TXQID_MASK		0x0f
+#define	UATH_TXQID_MINRATE	0x10	/* use min tx rate */
+#define	UATH_TXQID_FF		0x20	/* content is fast frame */
+	__be32	connid;		/* tx connection id */
+#define UATH_ID_INVALID	0xffffffff	/* for sending prior to connection */
+	__be32	flags;		/* non-zero if response desired */
+#define UATH_TX_NOTIFY	(1 << 24)	/* f/w will send a UATH_NOTIF_TX */
+	__be32	buflen;		/* payload length */
+} __packed;
 
-/* structure for command AR5523_CMD_SETUP */
-struct ar5523_cmd_setup {
-	__be32		magic1;
-	__be32		magic2;
-	__be32		magic3;
-	__be32		magic4;
-};
 
-/* structure for commands AR5523_CMD_READ_MAC and AR5523_CMD_READ_EEPROM */
-struct ar5523_read_mac {
-	__be32		len;
-	__u8		data[32];
-};
+#define AR5523_ID_BSS		2
+#define AR5523_ID_BROADCAST	0xffffffff
 
 /* structure for command UATH_CMD_WRITE_MAC */
 struct ar5523_write_mac {
@@ -243,22 +201,6 @@ struct ar5523_write_mac {
 } __packed;
 
 
-/* structure for command AR5523_CMD_0B */
-struct ar5523_cmd_0b {
-	__be32		code;
-	__be32		reserved;
-	__be32		size;
-	__u8		data[44];
-};
-
-/* structure for command AR5523_CMD_0C */
-struct ar5523_cmd_0c {
-	__be32		magic1;
-	__be32		magic2;
-	__be32		magic3;
-};
-
-
 struct ar5523_cmd_rateset {
 	__u8		length;
 #define AR5523_MAX_NRATES	32
@@ -328,8 +270,6 @@ struct ar5523_cmd_create_connection {
 
 
 
-
-
 /* structure for command AR5523_CMD_SET_LED */
 struct ar5523_cmd_led {
 	__be32		which;
@@ -348,27 +288,6 @@ struct ar5523_cmd_xled {
 	__be32		mode;
 };
 
-
-/* structure for command AR5523_CMD_CRYPTO */
-struct ar5523_cmd_crypto {
-	__be32		keyidx;
-#define AR5523_DEFAULT_KEY	6
-
-	__be32		magic1;
-	__be32		size;
-	__be32		reserved1;
-	__be32		mask;
-#define AR5523_ADDR_LEN		6		/* size of 802.11 address */
-	__u8		addr[AR5523_ADDR_LEN];
-	__be16		reserved2;
-	__be32		flags;
-	__be32		reserved3[2];
-	__u8		key[68];
-	__u8		magic2[136];
-	__u8		magic3[136];
-};
-
-
 /* structure for command AR5523_CMD_SET_QUEUE */
 struct ar5523_qinfo {
 	__be32		qid;
@@ -406,17 +325,6 @@ struct ar5523_cmd_rx_filter {		/* WDCMSG
 #define UATH_FILTER_OP_RESTORE		0x4
 } __packed;
 
-
-/* structure for command AR5523_CMD_SET_BSSID */
-struct ar5523_cmd_bssid {
-	__be32		reserved1;
-	__be32		flags1;
-	__be32		flags2;
-	__be32		reserved2;
-	__be32		len;
-	__u8		bssid[AR5523_ADDR_LEN];
-};
-
 enum {
 	CFG_NONE,			/* Sentinal to indicate "no config" */
 	CFG_REG_DOMAIN,			/* Regulatory Domain */

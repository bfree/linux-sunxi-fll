From 2739ae3b0fc78faabddee013661f96d181cc4969 Mon Sep 17 00:00:00 2001
From: Pontus Fuchs <pontus.fuchs@gmail.com>
Date: Fri, 7 Sep 2012 14:56:24 +0200
Subject: [PATCH 19/82] Fix checkpatch warnings

Misc whitespace and other style cleanups
---
 ar5523.c |  110 ++++++++++++++++++++++++++++++++------------------------------
 1 file changed, 56 insertions(+), 54 deletions(-)

--- a/drivers/net/wireless/ath/ar5523/ar5523.c
+++ b/drivers/net/wireless/ath/ar5523/ar5523.c
@@ -110,7 +110,7 @@ enum AR5523_flags {
 struct ar5523_tx_cmd {
 	struct	list_head	list;
 	int			id;
-        struct ar5523		*ar;
+	struct ar5523		*ar;
 	struct urb		*urb_tx;
 	struct urb		*urb_rx;
 	void			*buf_tx;
@@ -123,7 +123,7 @@ struct ar5523_tx_cmd {
 };
 
 struct ar5523_rx_cmd {
-        struct ar5523		*ar;
+	struct ar5523		*ar;
 	struct urb		*urb;
 	void			*buf;
 };
@@ -164,7 +164,7 @@ struct ar5523 {
 	struct ieee80211_channel channels[14];
 	struct ieee80211_rate	rates[12];
 	struct ieee80211_supported_band band;
-	struct ieee80211_vif 	*vif;
+	struct ieee80211_vif	*vif;
 
 };
 
@@ -184,11 +184,11 @@ enum {
 	AR5523_CMD_FLAG_MAGIC	= (1 << 2),
 };
 
-#define ar5523_dbg(ar, format, arg...)            \
+#define ar5523_dbg(ar, format, arg...) \
 	dev_dbg(&(ar)->dev->dev, format, ## arg)
-#define ar5523_err(ar, format, arg...)            \
+#define ar5523_err(ar, format, arg...) \
 	dev_err(&(ar)->dev->dev, format, ## arg)
-#define ar5523_info(ar, format, arg...)            \
+#define ar5523_info(ar, format, arg...)	\
 	dev_info(&(ar)->dev->dev, format, ## arg)
 
 /*
@@ -226,8 +226,7 @@ static void ar5523_read_reply(struct ar5
 				   cmd->olen, olen);
 			cmd->olen = 0;
 			cmd->res = -EOVERFLOW;
-		}
-		else {
+		} else {
 			cmd->olen = olen;
 			memcpy(cmd->odata, &rp[1], olen);
 			cmd->res = 0;
@@ -283,7 +282,8 @@ static void ar5523_cmd_rx_cb(struct urb
 		return;
 	}
 
-	ar5523_dbg(ar, "%s code %02x priv %d\n", __func__, be32_to_cpu(hdr->code) & 0xff, hdr->priv);
+	ar5523_dbg(ar, "%s code %02x priv %d\n", __func__,
+		   be32_to_cpu(hdr->code) & 0xff, hdr->priv);
 
 	hdr->code = be32_to_cpu(hdr->code);
 	hdr->len = be32_to_cpu(hdr->len);
@@ -318,7 +318,8 @@ static void ar5523_cmd_tx_cb(struct urb
 	struct ar5523 *ar = cmd->ar;
 
 	if (urb->status) {
-		ar5523_err(ar, "Failed to TX command. Status = %d\n", urb->status);
+		ar5523_err(ar, "Failed to TX command. Status = %d\n",
+			   urb->status);
 		cmd->res = urb->status;
 		free_tx_cmd(ar, cmd);
 		complete(&cmd->done);
@@ -354,7 +355,7 @@ static int ar5523_cmd(struct ar5523 *ar,
 			msleep(3000);
 			wait_event(ar->tx_cmd_wait, 1);
 		}
-	} while(!cmd);
+	} while (!cmd);
 
 
 	/* always bulk-out a multiple of 4 bytes */
@@ -383,7 +384,7 @@ static int ar5523_cmd(struct ar5523 *ar,
 		free_tx_cmd(ar, cmd);
 		ar5523_err(ar, "could not send command 0x%x, error=%d\n",
 			       code, error);
-		
+
 		return error;
 	}
 
@@ -405,8 +406,8 @@ static int ar5523_cmd(struct ar5523 *ar,
 
 	if (!wait_for_completion_timeout(&cmd->done, 2 * HZ)) {
 		cmd->odata = NULL;
-		ar5523_err(ar, "timeout waiting for command "
-				"%02x reply\n", code);
+		ar5523_err(ar, "timeout waiting for command %02x reply\n",
+			   code);
 		cmd->res = -EIO;
 		free_tx_cmd(ar, cmd);
 	}
@@ -417,7 +418,7 @@ static int ar5523_cmd(struct ar5523 *ar,
 static int ar5523_cmd_write(struct ar5523 *ar, u32 code, const void *data,
 		int len, int flags)
 {
-	flags &= ~AR5523_CMD_FLAG_READ; 
+	flags &= ~AR5523_CMD_FLAG_READ;
 	return ar5523_cmd(ar, code, data, len, NULL, 0, flags);
 }
 
@@ -438,10 +439,9 @@ static int ar5523_config(struct ar5523 *
 	*(u32 *)write.data = cpu_to_be32(val);
 
 	error = ar5523_cmd_write(ar, WDCMSG_TARGET_SET_CONFIG, &write,
-	    3 * sizeof (u32), 0);
-	if (error != 0) {
+				 3 * sizeof(u32), 0);
+	if (error != 0)
 		ar5523_err(ar, "could not write register 0x%02x\n", reg);
-	}
 	return error;
 }
 
@@ -457,7 +457,7 @@ static int ar5523_config_multi(struct ar
 
 	/* properly handle the case where len is zero (reset) */
 	error = ar5523_cmd_write(ar, WDCMSG_TARGET_SET_CONFIG, &write,
-	    (len == 0) ? sizeof (u32) : 2 * sizeof (u32) + len, 0);
+	    (len == 0) ? sizeof(u32) : 2 * sizeof(u32) + len, 0);
 	if (error != 0) {
 		ar5523_err(ar, "could not write %d bytes to register 0x%02x\n",
 			   len, reg);
@@ -485,14 +485,14 @@ static int ar5523_get_capability(struct
 
 	cap = cpu_to_be32(cap);
 	error = ar5523_cmd_read(ar, WDCMSG_TARGET_GET_CAPABILITY,
-	    &cap, sizeof cap, val, sizeof(u32), AR5523_CMD_FLAG_MAGIC);
+	    &cap, sizeof(cap), val, sizeof(u32), AR5523_CMD_FLAG_MAGIC);
 	if (error != 0) {
 		ar5523_err(ar, "could not read capability %u\n",
 		    be32_to_cpu(cap));
-		return (error);
+		return error;
 	}
 	*val = be32_to_cpu(*val);
-	return (error);
+	return error;
 }
 
 static int ar5523_get_devcap(struct ar5523 *ar)
@@ -500,7 +500,7 @@ static int ar5523_get_devcap(struct ar55
 #define	GETCAP(x) do {				\
 	error = ar5523_get_capability(ar, x, &cap);		\
 	if (error != 0)					\
-		return (error);				\
+		return error;				\
 	ar5523_info(ar, "Cap: "			\
 	    "%s=0x%08x\n", #x, cap);	\
 } while (0)
@@ -600,7 +600,7 @@ static int ar5523_set_rxfilter(struct ar
 
 	ar5523_dbg(ar, "setting Rx filter=0x%x flags=0x%x\n", bits, op);
 	return ar5523_cmd_write(ar, WDCMSG_RX_FILTER, &rxfilter,
-	    sizeof rxfilter, 0);
+	    sizeof(rxfilter), 0);
 }
 
 static int ar5523_reset_tx_queues(struct ar5523 *ar)
@@ -638,7 +638,7 @@ static int ar5523_set_chan(struct ar5523
 	ar5523_dbg(ar, "set chan flags 0x%x freq %d\n",
 		   be32_to_cpu(reset.flags),
 		   conf->channel->center_freq);
-	return ar5523_cmd_write(ar, WDCMSG_RESET, &reset, sizeof reset, 0);
+	return ar5523_cmd_write(ar, WDCMSG_RESET, &reset, sizeof(reset), 0);
 }
 
 static int ar5523_wme_init(struct ar5523 *ar)
@@ -754,7 +754,9 @@ static void ar5523_data_rx_cb(struct urb
 	chunk = (struct ar5523_chunk *) data->skb->data;
 
 	if (chunk->flags != UATH_CFLAGS_FINAL)
-		printk("chunk seq: %d flags: %02x len: %d\n", chunk->seqnum, chunk->flags, be16_to_cpu(chunk->length));
+		ar5523_dbg(ar, "chunk seq: %d flags: %02x len: %d\n",
+			   chunk->seqnum, chunk->flags,
+			   be16_to_cpu(chunk->length));
 
 	if ((chunk->flags & UATH_CFLAGS_FINAL) == 0) {
 		ar5523_err(ar, "No final in RX frame\n");
@@ -776,7 +778,8 @@ static void ar5523_data_rx_cb(struct urb
 		goto skip;
 
 	if (be32_to_cpu(desc->status) != 0) {
-		ar5523_dbg(ar, "Bad RX status (0x%x). Skip\n", be32_to_cpu(desc->status));
+		ar5523_dbg(ar, "Bad RX status (0x%x). Skip\n",
+			   be32_to_cpu(desc->status));
 		goto skip;
 	}
 
@@ -799,7 +802,7 @@ static void ar5523_data_rx_cb(struct urb
 	rx_status->signal = -95 + be32_to_cpu(desc->rssi);
 
 	ieee80211_rx_irqsafe(hw, data->skb);
-	
+
 	data->skb = __dev_alloc_skb(ar->rxbufsz, GFP_ATOMIC);
 	if (!data->skb) {
 		ar5523_err(ar, "could not allocate rx skbuff\n");
@@ -837,7 +840,7 @@ static int ar5523_alloc_rx_bufs(struct a
 {
 	int error = -ENOMEM;
 	int i;
-	
+
 	for (i = 0; i < AR5523_RX_DATA_COUNT; i++) {
 		struct ar5523_rx_data *data = &ar->rx_data[i];
 
@@ -847,7 +850,7 @@ static int ar5523_alloc_rx_bufs(struct a
 			ar5523_err(ar, "could not allocate rx data urb\n");
 			goto out;
 		}
-	
+
 		data->skb = dev_alloc_skb(ar->rxbufsz);
 		if (!data->skb) {
 			ar5523_err(ar, "could not allocate rx skbuff\n");
@@ -871,8 +874,8 @@ static int ar5523_alloc_rx_bufs(struct a
 
 	return 0;
 
- out:
- 	while (--i >= 0) {
+out:
+	while (--i >= 0) {
 		struct ar5523_rx_data *data = &ar->rx_data[i];
 
 		usb_kill_urb(data->urb);
@@ -896,7 +899,7 @@ static int ar5523_start(struct ieee80211
 
 	mutex_lock(&ar->mutex);
 	val = cpu_to_be32(0);
-	ar5523_cmd_write(ar, WDCMSG_BIND, &val, sizeof val, 0);
+	ar5523_cmd_write(ar, WDCMSG_BIND, &val, sizeof(val), 0);
 
 	/* set MAC address */
 	ar5523_config_multi(ar, CFG_MAC_ADDR, &ar->hw->wiphy->perm_addr,
@@ -941,7 +944,7 @@ static int ar5523_start(struct ieee80211
 	}
 
 	val = cpu_to_be32(TARGET_DEVICE_AWAKE);
-	ar5523_cmd_write(ar, WDCMSG_SET_PWR_MODE, &val, sizeof val, 0);
+	ar5523_cmd_write(ar, WDCMSG_SET_PWR_MODE, &val, sizeof(val), 0);
 	/* XXX? check */
 	ar5523_cmd_write(ar, WDCMSG_RESET_KEY_CACHE, NULL, 0, 0);
 
@@ -1057,7 +1060,7 @@ static void ar5523_tx(struct ieee80211_h
 	urb = usb_alloc_urb(0, GFP_ATOMIC);
 	if (!urb)
 		goto out_free_skb;
-	
+
 	data->ar = ar;
 
 	desc = (struct ar5523_tx_desc *)skb_push(skb, sizeof(*desc));
@@ -1208,10 +1211,9 @@ static int ar5523_set_basic_rates(struct
 	ar5523_create_rateset(ar, vif, bss, &rates.rateset, true);
 
 	return ar5523_cmd_write(ar, WDCMSG_SET_BASIC_RATE,
-	    &rates, sizeof rates, 0);
+				&rates, sizeof(rates), 0);
 }
 
-
 static int ar5523_create_connection(struct ar5523 *ar,
 				     struct ieee80211_vif *vif,
 				     struct ieee80211_bss_conf *bss)
@@ -1226,13 +1228,13 @@ static int ar5523_create_connection(stru
 
 	ar5523_create_rateset(ar, vif, bss, &create.connattr.rateset, false);
 
-	if (1)
+	if (1) //TODO
 		create.connattr.wlanmode = cpu_to_be32(WLAN_MODE_11g);
 	else
 		create.connattr.wlanmode = cpu_to_be32(WLAN_MODE_11b);
 
 	return ar5523_cmd_write(ar, WDCMSG_CREATE_CONNECTION, &create,
-	    sizeof create, 0);
+				sizeof(create), 0);
 
 }
 
@@ -1247,7 +1249,7 @@ static int ar5523_write_associd(struct a
 	associd.timoffset = cpu_to_be32(0x3b);	/* XXX */
 	memcpy(associd.bssid, bss->bssid, ETH_ALEN);
 	return ar5523_cmd_write(ar, WDCMSG_WRITE_ASSOCID, &associd,
-	    sizeof associd, 0);
+				sizeof(associd), 0);
 }
 
 static void ar5523_bss_info_changed(struct ieee80211_hw *hw,
@@ -1278,7 +1280,7 @@ static void ar5523_bss_info_changed(stru
 			return;
 		}
 
-		error = ar5523_write_associd(ar, bss);	
+		error = ar5523_write_associd(ar, bss);
 		if (error) {
 			ar5523_err(ar, "could not set association\n");
 			return;
@@ -1293,8 +1295,7 @@ static void ar5523_bss_info_changed(stru
 		/* start statistics timer */
 //		mod_timer(&ar->stat_timer, jiffies + HZ);
 
-	}
-	else {
+	} else {
 		ar5523_set_led(ar, AR5523_LED_LINK, 0);
 		ar5523_set_led(ar, AR5523_LED_ACTIVITY, 0);
 	}
@@ -1372,7 +1373,7 @@ static void ar5523_free_tx_cmds(struct a
 static int ar5523_alloc_tx_cmds(struct ar5523 *ar)
 {
 	int error = -ENOMEM;
-        int i;
+	int i;
 
 	for (i = 0; i < AR5523_TX_CMD_COUNT; i++) {
 		struct ar5523_tx_cmd *cmd = &ar->tx_cmd[i];
@@ -1380,7 +1381,7 @@ static int ar5523_alloc_tx_cmds(struct a
 		cmd->ar = ar;
 		cmd->id = i;
 		cmd->urb_rx = usb_alloc_urb(0, GFP_KERNEL);
-		cmd->urb_tx= usb_alloc_urb(0, GFP_KERNEL);
+		cmd->urb_tx = usb_alloc_urb(0, GFP_KERNEL);
 		if (!cmd->urb_rx || !cmd->urb_tx) {
 			ar5523_err(ar, "could not allocate urb\n");
 			goto out;
@@ -1391,7 +1392,7 @@ static int ar5523_alloc_tx_cmds(struct a
 		cmd->buf_tx = usb_alloc_coherent(ar->dev, AR5523_MAX_TXCMDSZ,
 					      GFP_KERNEL,
 					    &cmd->urb_tx->transfer_dma);
-		if (!cmd->buf_rx ) { //TODO
+		if (!cmd->buf_rx) { //TODO
 			ar5523_err(ar, "could not allocate tx buffer\n");
 			usb_free_urb(cmd->urb_rx);
 			goto out;
@@ -1402,7 +1403,7 @@ static int ar5523_alloc_tx_cmds(struct a
 	return 0;
 
 out:
- 	while (--i >= 0) {
+	while (--i >= 0) {
 		struct ar5523_tx_cmd *cmd = &ar->tx_cmd[i];
 
 		usb_free_coherent(ar->dev, AR5523_MAX_TXCMDSZ,
@@ -1411,7 +1412,7 @@ out:
 				  cmd->buf_rx, cmd->urb_rx->transfer_dma);
 		usb_free_urb(cmd->urb_tx);
 		usb_free_urb(cmd->urb_rx);
-		list_del(&cmd->list);		
+		list_del(&cmd->list);
 	}
 
 	return error;
@@ -1427,14 +1428,14 @@ static int ar5523_host_available(struct
 	setup.sw_ver_patch = cpu_to_be32(ATH_SW_VER_PATCH);
 	setup.sw_ver_build = cpu_to_be32(ATH_SW_VER_BUILD);
 	return ar5523_cmd_read(ar, WDCMSG_HOST_AVAILABLE,
-		&setup, sizeof setup, NULL, 0, 0);
+			       &setup, sizeof(setup), NULL, 0, 0);
 }
 
 static int ar5523_get_devstatus(struct ar5523 *ar)
 {
 	u8 macaddr[ETH_ALEN];
 	int error;
-	
+
 	/* retrieve MAC address */
 	error = ar5523_get_status(ar, ST_MAC_ADDR, macaddr, ETH_ALEN);
 	if (error != 0) {
@@ -1549,7 +1550,7 @@ static int ar5523_load_firmware(struct u
 	int len, offset;
 	int foolen; /* XXX(hch): handle short transfers */
 	int error = -ENXIO;
-	
+
 	if (request_firmware(&fw, AR5523_FIRMWARE_FILE, &dev->dev)) {
 		dev_err(&dev->dev, "no firmware found: %s\n",
 			AR5523_FIRMWARE_FILE);
@@ -1701,7 +1702,7 @@ static int ar5523_probe(struct usb_inter
 	}
 
 	ar5523_info(ar, "MAC/BBP AR5523, RF AR%c112\n",
-			(id->driver_info & AR5523_FLAG_ABG) ? '5': '2');
+			(id->driver_info & AR5523_FLAG_ABG) ? '5' : '2');
 
 	setup_timer(&ar->stat_timer, ar5523_stat, (unsigned long)ar);
 
@@ -1743,7 +1744,7 @@ static void ar5523_disconnect(struct usb
 	ar5523_dbg(ar, "detaching\n");
 
 	ieee80211_unregister_hw(hw);
-	
+
 	del_timer_sync(&ar->stat_timer);
 
 	ar5523_free_tx_cmds(ar);
@@ -1774,7 +1775,8 @@ static struct usb_device_id ar5523_id_ta
 	AR5523_DEVICE_UX(0x2001, 0x3a04),	/* Dlink / DWLAG122 */
 	AR5523_DEVICE_UG(0x1690, 0x0712),	/* Gigaset / AR5523 */
 	AR5523_DEVICE_UG(0x1690, 0x0710),	/* Gigaset / SMCWUSBTG */
-	AR5523_DEVICE_UG(0x129b, 0x160c),	/* Gigaset / USB stick 108 (CyberTAN Technology) */
+	AR5523_DEVICE_UG(0x129b, 0x160c),	/* Gigaset / USB stick 108
+						   (CyberTAN Technology) */
 	AR5523_DEVICE_UG(0x16ab, 0x7801),	/* Globalsun / AR5523_1 */
 	AR5523_DEVICE_UX(0x16ab, 0x7811),	/* Globalsun / AR5523_2 */
 	AR5523_DEVICE_UG(0x0d8e, 0x7802),	/* Globalsun / AR5523_3 */
